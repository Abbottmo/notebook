# TCP/IP 协议

![image-20201027221054991](img\linux高性能服务器编程\image-20201027221054991.png)



### 数据链路层  

实现网卡接口的网络驱动程序，以处理数据在物理媒介上的传输

常用协议 ARP (address resolve protocol 地址解析协议) RARP（reverse address resolve protocol）

 

### 网络层

实现数据包的选择和转发 ，最重要的是**IP 协议**   

ICMP(internet control message protocol 因特网控制报文协议)  用于检测网络连接 ，**使用同层IP协议提供的服务**

![image-20201027221711135](img\linux高性能服务器编程\image-20201027221711135.png)



### 传输层 

为两台主机提供端到端的通信 传输层只关心通信的起始端和目的端，不关心数据包的中转



![image-20201027221936945](img\linux高性能服务器编程\image-20201027221936945.png)



传输层协议**有 TCP UDP SCTP协议**

### 应用层

处理应用程序的逻辑，在用户空间实现

协议 ping是应用程序，使用ICMP 

telnet协议 远程登录

OSPF （open shortest path first 开放最短路径优先） 

DNS 



### 封装

![image-20201027222332145](img\linux高性能服务器编程\image-20201027222332145.png)

![image-20201027222414934](img\linux高性能服务器编程\image-20201027222414934.png)

经过IP封装的数据称为IP数据报，包括头部信息和数据部分，数据部分是TCP UDP  ICMP 报文

数据链路层封装的是帧



## IP协议详解

IP 协议为上层提供**无状态，无连接 不可靠的服务**

### IPV4 头部结构

通常**20字节**

![image-20201027223019469](img\linux高性能服务器编程\image-20201027223019469.png)



### IPV6 头部

由固定40字节头部和可变长扩展头部组成

![image-20201027223648366](img\linux高性能服务器编程\image-20201027223648366.png)



### TCP 协议详解

TCP 面向连接，字节流，可靠传输

使用TCP 通信双方必须建立连接，分配必要的资源以管理连接的状态和连接上数据的传输 

TCP固定头部

![image-20201027233338296](img\linux高性能服务器编程\image-20201027233338296.png)

![image-20201027235314086](img\linux高性能服务器编程\image-20201027235314086.png)

TIME_WAIT 状态 目的

可靠终止TCP 连接

保证让迟到的TCP 有足够时间被识别丢弃



### TCP 超时重传

TCP模块为每个TCP报文段维持一个重传定时器，该定时器再TCP 报文第一次发送时启动，如果超时未收到对方的应答，TCP模块将重传TCP 报文段并重置定时器

超时重传失败之后底层的IP 和ARP 会接管，直到放弃连接

/proc/sys/net/ipv4/tcp_retries1  指定在底层IP 接管之前TCP 最少重传次数 默认3

 /proc/sys/net/ipv4/tcp_retries2   指定连接放弃前TCP 最多可以重传次数  默认15  对应13-30min



### 拥塞控制

目的：提高网络利用率，降低丢包率，保证网络资源对每条数据流的公平性 

四个部分：慢启动  拥塞避免  快速重传 快速恢复

拥塞控制的最终受控变量是发送端向网络一次连续写入（收到其中第一个数据的确认之前）的数据量，成为SWND (send window **发送窗口** )，同时接收方可以通过**接收窗口**RWND 控制发送端的SWND ，同时发送端引入**拥塞窗口**CWND（congestion window），实际的swnd = min(rwnd,cwnd)



### 慢启动 

CWND 按照指数级扩大，就是所谓的慢启动

慢启动门限 ssthresh ，当CWND 超过时，TCP拥塞控制进入拥塞避免阶段 ，此时CWND 按照线性方式增加

发送端判断发生拥塞

传输超时   使用慢启动，拥塞避免

接收到重复的确认报文段  使用快速重传 和 快速恢复



#### 快重传和快速恢复

发送端**连续收到3个重复的确认报文段，**认为发生了拥塞，将启用快速重传和快速恢复



### internet web服务器

#### http请求方法

![image-20201028122800056](img\linux高性能服务器编程\image-20201028122800056.png)



![image-20201028122853507](img\linux高性能服务器编程\image-20201028122853507.png)



![image-20201028122918064](img\linux高性能服务器编程\image-20201028122918064.png)



#### http应答

![image-20201028123024139](img\linux高性能服务器编程\image-20201028123024139.png)



#### 状态码

![image-20201028123050456](img\linux高性能服务器编程\image-20201028123050456.png)



![image-20201028123137314](img\linux高性能服务器编程\image-20201028123137314.png)





## linux 网络编程

socket 地址api

![image-20201028130647422](img\linux高性能服务器编程\image-20201028130647422.png)

#### ip 地址转换

![image-20201028132432854](img\linux高性能服务器编程\image-20201028132432854.png)

![image-20201028132535616](img\linux高性能服务器编程\image-20201028132535616.png)

socket 选项

![image-20201028133519381](img\linux高性能服务器编程\image-20201028133519381.png)



### 服务器编程框架

![image-20201028192420872](img\linux高性能服务器编程\image-20201028192420872.png)

| 模块         | 单个服务器程序         | 服务器集群                   |
| ------------ | ---------------------- | ---------------------------- |
| I/O 处理     | 处理客户连接，读写数据 | 作为接入服务器，实现负载均衡 |
| 逻辑单元     | 业务进程或者线程       | 逻辑服务器                   |
| 网络存储单元 | 本地数据库 文件 缓存   | 数据库服务器                 |
| 请求队列     | 各单元间通信方式       | 各服务器间永久TCP 连接       |

I/O 处理单元负责管理客户的连接，对于服务器集群，I/O 处理单元是一个专门的接入服务器，实现负载均衡。

逻辑单元通常是一个进程或者线程，分析处理客户数据，对于服务器集群，一个逻辑单元本身就是一台服务器，以实现对多个客户任务的并行处理。

请求队列时各单元间的通信方式的抽象，I/O 处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理请求。对于服务器集群，请求队列时各台服务器之间预先建立的，静态的，永久的TCP 连接。



#### I/O 模型

![image-20201028205355514](img\linux高性能服务器编程\image-20201028205355514.png)



#### 两种高效的事件处理类型

Reactor 模式

主线程（I/O处理单元）负责监听文件描述符事件，有的话就通知工作线程（逻辑单元），

工作线程完成读写数据，接收新的连接，处理客户请求

同步I/O 模型实现reactor模式工作流程

1、主线程在epoll内核事件表注册**socket上读就绪事件**

2、主线程调用epoll_wait 等待socket有数据可读

3、当socket有数据可读时，epoll_wait 通知主线程，**主线程将socket可读事件放入请求队列**

4、请求队列中的工作线程被唤醒，从socket读取数据，处理请求，往epoll 内核注册**写就绪事件**

5、主线程调用epoll_wait  等待socket 可写

6、socket可写时，epoll_wait 通知主线程，**主线程将socket可写事件放入请求队列**

7、 请求队列中的工作线程唤醒，往socket上写入服务器处理客户请求的结果

![image-20201028210332428](img\linux高性能服务器编程\image-20201028210332428.png)

proactor 模式

所有的I/O操作交给主线程和内核来处理，工作线程仅仅负责业务逻辑

使用异步I/O 实现proactor 模式

1、 主线程调用aio_read 向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成如何通知应用程序

2、主线程继续处理其他逻辑

3、socket上数据读入用户缓冲区后，内核向用户程序发送信号，通知可用

4、应用程序预定义好的信号处理函数选择一个工作线程来处理客户请求，工作线程处理完成之后调用aio_write 函数向内核注册socket 上的写完成事件，并告诉内核用户写缓冲的位置，以及写操作完成如何通知应用程序

5、主线程处理其他逻辑

6、用户缓冲区数据写入socket后，内核将向应用程序发送信号，通知应用程序数据发送完毕

7、应用程序预定义的信号处理函数选择工作线程善后

![image-20201028214527487](img\linux高性能服务器编程\image-20201028214527487.png)



半同步 /半反应堆模型

![image-20201028231825755](img\linux高性能服务器编程\image-20201028231825755.png)



异步线程只有一个，就是主线程，负责监听所有的socket上事件，如果监听到socket上有可读事件发生，

缺点：主线程和工作线程共享请求队列，需要对队列加锁保护，耗费cpu时间

每个工作线程同一时间只能处理一个客户请求，客户数量多工作线程少时则客户响应慢



高效的半同步/半异步模式

![image-20201028232300305](img\linux高性能服务器编程\image-20201028232300305.png)

主线程只管监听socket，连接socket由工作线程管理，当有新的连接时，主线程接受并将新返回的socket派发给某个工作线程，此后该新socket所有的IO都由选中的工作线程处理



领导者/追随者模式

多个工作线程轮流获得事件源集合，轮流监听，分发并处理事件的模式。

![image-20201029000010627](img\linux高性能服务器编程\image-20201029000010627.png)



### IO复用

select



































